package com.general_hello.commands.OtherEvents;

import com.general_hello.commands.Config;
import com.general_hello.commands.Database.DatabaseManager;
import com.general_hello.commands.commands.PrefixStoring;
import com.general_hello.commands.commands.Register.Data;
import net.dv8tion.jda.api.EmbedBuilder;
import net.dv8tion.jda.api.entities.Category;
import net.dv8tion.jda.api.entities.Emoji;
import net.dv8tion.jda.api.events.interaction.ButtonClickEvent;
import net.dv8tion.jda.api.hooks.ListenerAdapter;
import net.dv8tion.jda.api.interactions.components.Button;
import org.jetbrains.annotations.NotNull;

import java.awt.*;
import java.util.List;

public class OnButtonClick extends ListenerAdapter {
    @Override
    public void onButtonClick(@NotNull ButtonClickEvent event) {
        // users can spoof this id so be careful what you do with this
        String[] id = event.getComponentId().split(":"); // this is the custom id we specified in our button
        String authorId = id[0];
        String type = id[1];
        // When storing state like this is it is highly recommended to do some kind of verification that it was generated by you, for instance a signature or local cache
        event.deferEdit().queue(); // acknowledge the button was clicked, otherwise the interaction will fail

        if (!authorId.equals("0000") && !authorId.equals(event.getUser().getId()))
            return;

        switch (type)
        {
            case "kick":
                event.getHook().editOriginal("Bye ðŸ˜«").queue();
                event.getGuild().leave().queue();
                // fallthrough delete the prompt message with our buttons
                break;
            case "nope":
            case "end":
                event.getHook().deleteOriginal().queue();
                break;
            case "user":
                event.getHook().editOriginalEmbeds(helpCrap(4, event).build()).queue();
                break;
            case "bot":
                event.getHook().editOriginalEmbeds(helpCrap(2, event).build()).queue();
                break;
            case "info":
                event.getHook().editOriginalEmbeds(helpCrap(1, event).build()).queue();
                break;
            case "mod":
                event.getHook().editOriginalEmbeds(helpCrap(3, event).build()).queue();
                break;
            case "accept":
                String arrow = "<a:arrow_1:862525611465113640>";

                event.getHook().deleteOriginal().queue();
                EmbedBuilder em = new EmbedBuilder().setTitle("Stored data").setFooter("Press the Accept button if you accept the data that will be stored!\n");
                em.setDescription("The bot stores the following data:\n" +
                        arrow + " Reads all sent messages in the server the bot is in.\n" +
                        arrow + " Reads all the messages you sent to the bot.\n" +
                        arrow + " Reads all the calls you made.\n" +
                        arrow + " Reads your user name, profile picture, nitro status, and user id.\n" +
                        arrow + " Reads all the permissions you have on that server." +
                        arrow + " Listens to everything you say during voicecalls.\n");
                event.getChannel().sendMessageEmbeds(em.build()).setActionRow(
                        Button.primary("0000:yes", "Accept").withEmoji(Emoji.fromEmote("verify", Long.parseLong("803768813110951947"), true))
                ).queue();
                break;
            case "yes":
                event.getHook().deleteOriginal().queue();
                event.getChannel().sendMessage("<a:thanks:863989523461177394> Thank you for accepting the rules and data that will be stored.").queue();
                event.getChannel().sendMessage("<a:question:863989523368247346> What do you want your username for calls to be?").queue();
                Data.progress.put(event.getUser(), 1);
                break;
            case "acceptConnect4":
                final long guildID = event.getGuild().getIdLong();
                String prefix = PrefixStoring.PREFIXES.computeIfAbsent(guildID, DatabaseManager.INSTANCE::getPrefix);
                List<Category> connect4Category = event.getGuild().getCategoriesByName("Connect4", false);
                if (connect4Category.isEmpty()){
                    event.getGuild().createCategory("Connect4").setPosition(1).queue();
                }

                connect4Category.get(0).createTextChannel("Connect").setPosition(1).setTopic("Connect4 games with your friend!").queue();
                event.getChannel().sendMessage(event.getMember().getAsMention() + " accepted the Connect4 game! Kindly navigate to " + " and send " + prefix + "startconnect4 once you are ready!").queue();
                break;
        }
    }

    public EmbedBuilder helpCrap (int number, ButtonClickEvent ctx) {
        EmbedBuilder embedBuilder = new EmbedBuilder();
        final long guildID = ctx.getGuild().getIdLong();
        String prefix = PrefixStoring.PREFIXES.computeIfAbsent(guildID, (id) -> Config.get("prefix"));

        switch (number) {
            case 1:
                embedBuilder.setTitle("Information Commands");
                embedBuilder.setColor(Color.red);
                embedBuilder.addField("1.) Profile Command","`" + prefix + "profile`", false);
                embedBuilder.addField("2.) Server Information Command","`" + prefix + "serverinfo`", false);
                embedBuilder.addField("3.) Mod Information Command ","`" + prefix + "mods`", false);

                embedBuilder.setFooter("\nType " + prefix + "help [command name] to see what they do");
                break;
            case 2:
                embedBuilder.setTitle("About the Bot Commands");
                embedBuilder.setColor(Color.blue);
                embedBuilder.addField("1.) Server List Command","`" + prefix + "serverlist`", false);
                embedBuilder.addField("2.) Server Count Command","`" + prefix + "server`", false);
                embedBuilder.addField("3.) Bug Command","`" + prefix + "bug`", false);
                embedBuilder.addField("4.) Setting Command ","`" + prefix + "settings`", false);
                embedBuilder.addField("5.) Upgrade to ***Premium*** Command ","`" + prefix + "premium`", false);
                embedBuilder.addField("6.) Set Prefix Command", "`" + prefix + "setprefix`", false);
                embedBuilder.addField("7.) Use Code Command", "`" + prefix + "code`", false);
                embedBuilder.addField("8.) Uptime Command", "`" + prefix + "uptime`", false);

                embedBuilder.setFooter("\nType " + prefix + "help [command name] to see what they do");
                break;
            case 3:
                embedBuilder.setTitle("Moderation Commands");
                embedBuilder.setColor(Color.red);
                embedBuilder.addField("1.) Kick Command", "`" + prefix + "kick`", false);
                embedBuilder.addField("2.) Ban Command", "`" + prefix + "ban`", false);
                embedBuilder.addField("3.) Mute Command", "`" + prefix + "mute`", false);
                embedBuilder.addField("4.) Deafen Command", "`" + prefix + "deafen`", false);
                embedBuilder.setFooter("\nType " + prefix + "help [command name] to see what they do");
                break;
            case 4:
                embedBuilder.setTitle("User Commands");
                embedBuilder.setColor(Color.red);
                embedBuilder.addField("1.) Register Command", "`" + prefix + "register`", false);

                embedBuilder.setFooter("\nType " + prefix + "help [command name] to see what they do");
                break;
        }
        return embedBuilder;
    }
}
